<html>
<head>
<style>
#startscreen {
	position: fixed;
	display: flex;
	align-items: center;
	justify-content: center;
	width: 100%;
	height: 100%;
	background-color: black;
	color: white;
	z-index: 10;
	font-size: x-large;
}

#endscreen {
	display: none;
	
	position: fixed;
	align-items: center;
	justify-content: center;
	width: 100%;
	height: 100%;
	background-color: black;
	color: white;
	z-index: 11;
	font-size: x-large;

}

#trialscore_wrapper {
	position: absolute;
	display: block;
  	text-align: center;
	top: 30%;
	width: 100%;
	color: white;
	font-size: xx-large;
	text-shadow: 2px 2px 3px black;
	/*background-color: black;*/
}

#trialscore {
	background-color: black;
	padding: 3px;
}

#trialscore:empty {
	display: none;
}

#answerprompt {
	position: absolute;
	display: block;
  	text-align: center;
	bottom: 70%;
	width: 100%;
	color: white;
	font-size: xx-large;
	background-color: black;
	cursor: none;

}

#endscreen * {
	font-size: x-large;
}

#startscreen * {
	font-size: x-large;
}

body {
	margin: 0;
	background-color: black;
}

body > canvas {
	cursor: none;
	display: block;
    margin: 0 auto;
}

.instruction {
	position: fixed;
	display: none;
	align-items: center;
	justify-content: center;
	width: 100%;
	height: 100%;
	background-color: black;
	color: white;
	z-index: 10;
	font-size: large;
	cursor: none;
}

.instruction > div {
	width: 50%;
	cursor: none;
}

</style>

</head>
<body>
<div style="position: absolute; font-size: large; color: white;">
	Total score: <span id="score"></span>
	<br>Trial number: <span id="trial_n"</span>
	<br>Trial score: <span id="trial_score"</span>
</div>

<div id="trialscore_wrapper">
<span id="trialscore"></span>
</div>

<div id="answerprompt">
</div>

<div class="instruction" id="forced_two_and_one_instruction">
<div>
<h1>TOPELI 2-1: Select the critical object</h1>
<p>Objects appear from left and right, they approach the center, and are visible for a moment. There may be more than one
object on one side.  Select with
arrow keys (&#8678; &#8680;) which side has the fastest object. i.e., from which side an object would reach the center line first. </p>
<p>Right answer gives 100 points, wrong answer -200 points.</p>
<p>Press any key to continue.</p>

<h1>TOPELI 2-1: Valitse kriittinen kohde</h1>
<p>Kohteet tulevat vasemmalta ja oikealta ja lähestyvät keskilinjaa. Ne ovat näkyvissä vain hetken. Yhdellä puolella voi olla useampia kohteita.
 Valitse nuolinäppäimillä (&#8678; &#8680;) kummalla puolella on nopein kohde, eli kummalta puolelta ruutua kohde saavuttaisi ruudun keskilinjan ensin.</p>
<p>Oikeasta vastauksesta 100 pistettä, Väärästä -200 pistettä.</p>
<p>Paina jotain näppäintä aloittaaksesi.</p>

</div>
</div>

<div class="instruction" id="forced_two_and_one_instruction_practice">
<div>
<h1>TOPELI 2-1: Select the critical object,  practice rounds</h1>
<p>Objects appear from left and right, they approach the center, and are visible for a moment. There may be more than one
object on one side.  Select with
arrow keys (&#8678; &#8680;) which side has the fastest object. i.e., from which side an object would reach the center line first. </p>
<p>Right answer gives 100 points, wrong answer -200 points.</p>
<p>Press any key to continue.</p>

<h1>TOPELI 2-1: Valitse kriittinen kohde, harjoituskierrokset</h1>
<p>Kohteet tulevat vasemmalta ja oikealta ja lähestyvät keskilinjaa. Ne ovat näkyvissä vain hetken. Yhdellä puolella voi olla useampia kohteita.
 Valitse nuolinäppäimillä (&#8678; &#8680;) kummalla puolella on nopein kohde, eli kummalta puolelta ruutua kohde saavuttaisi ruudun keskilinjan ensin.</p>
<p>Oikeasta vastauksesta 100 pistettä, Väärästä -200 pistettä.</p>
<p>Paina jotain näppäintä aloittaaksesi.</p>

</div>
</div>

<div class="instruction" id="forcedinstruction">
<div>
<h1>TOPELI 2: Select the critical object</h1>
<p>Objects appear from left and right and are visible for a moment. Select with
arrow keys (&#8678; &#8680;) which one is first at the center.</p>
<p>Right answer gives 100 points, wrong answer -200 points.</p>
<p>Press any key to continue.</p>

<h1>TOPELI 2: Valitse kriittinen kohde</h1>
<p>Kohteet tulevat vasemmalta ja oikealta ja lähestyvät keskilinjaa. Ne ovat näkyvissä vain hetken. Valitse 
nuolinäppäimillä (&#8678; &#8680;) kumpi kohde saavuttaisi ruudun keskilinjan ensin.</p>
<p>Oikeasta vastauksesta 100 pistettä, Väärästä -200 pistettä.</p>
<p>Paina jotain näppäintä aloittaaksesi.</p>

</div>
</div>

<div class="instruction" id="forcedinstruction_practice">
<div>
<h1> TOPELI 2: Select the critical object, practice round </h1>
<p>Objects appear from left and right and are visible for a moment. Select with
arrow keys (&#8678; &#8680;) which one is first at the center.</p>
<p>Right answer gives 100 points, wrong answer -200 points.</p>
<p>Press any key to continue.</p>

<h1> TOPELI 2: Valitse kriittinen kohde,  harjoituskierros</h1>
<p>Kohteet tulevat vasemmalta ja oikealta ja lähestyvät keskilinjaa. Ne ovat näkyvissä vain hetken. Valitse 
nuolinäppäimillä (&#8678; &#8680;) kumpi kohde saavuttaisi ruudun keskilinjan ensin.</p>
<p>Oikeasta vastauksesta 100 pistettä, Väärästä -200 pistettä.</p>
<p>Paina jotain näppäintä aloittaaksesi.</p>

</div>
</div>



<div class="instruction" id="nonforcedinstruction">
<div>
<h1>TOPELI 3: Select the critical object or pass</h1>
<p>Objects appear from left and right and are visible for a moment. Select with
arrow keys (&#8678; &#8680;) which one is first at the center, or pass giving
and answer by pressing down  &#8681;.</p>
<p>Right answer gives 100 points, wrong answer -200 points and passing gives 0 points.</p>
<p>Press any key to continue.</p>

<h1>TOPELI 3: Valitse kriittinen kohde tai ohita</h1>
<p>Kohteet tulevat vasemmalta ja oikealta ja lähestyvät keskilinjaa. Ne ovat näkyvissä vain hetken. Valitse 
nuolinäppäimillä (&#8678; &#8680;) kumpi kohde saavuttaisi ruudun keskilinjan ensin, tai ohita 
painamalla alanuolta &#8681; .</p>
<p>Oikeasta vastauksesta 100 pistettä, väärästä -200 pistettä. Ohittamisesta 0 pistettä </p>
<p>Paina jotain näppäintä aloittaaksesi.</p>


</div>
</div>


<div class="instruction" id="nonforcedinstruction_practice">
<div>
<h1>TOPELI 3: Select the critical object or pass, practice rounds</h1>
<p>Objects appear from left and right and are visible for a moment. Select with
arrow keys (&#8678; &#8680;) which one is first at the center, or pass giving
and answer by pressing down  &#8681;.</p>
<p>Right answer gives 100 points, wrong answer -200 points and passing gives 0 points.</p>
<p>Press any key to continue.</p>

<h1>TOPELI 3: Valitse kriittinen kohde tai ohita, harjoituskierros</h1>
<p>Kohteet tulevat vasemmalta ja oikealta ja lähestyvät keskilinjaa. Ne ovat näkyvissä vain hetken. Valitse 
nuolinäppäimillä (&#8678; &#8680;) kumpi kohde saavuttaisi ruudun keskilinjan ensin, tai ohita 
painamalla alanuolta &#8681; .</p>
<p>Oikeasta vastauksesta 100 pistettä, väärästä -200 pistettä. Ohittamisesta 0 pistettä </p>
<p>Paina jotain näppäintä aloittaaksesi.</p>

</div>
</div>




<div class="instruction" id="trialinstruction">
<div>
<h1>TOPELI 1: Select the critical object</h1>
<p>Objects appear from left and right and approach the center. Select with
arrow keys (&#8678; &#8680;) which one is first at the center.</p>
<p>The faster you decide, the more points you get. Wrong answer gives double negative points.</p>
<p>Press any key to continue.</p>

<h1>TOPELI 1: Valitse kriittinen kohde </h1>
<p>Kohteet tulevat vasemmalta ja oikealta ja lähestyvät keskilinjaa. Valitse nuolinäppäimillä (&#8678; &#8680;) kumpi kohde saavuttaa keskilinjan ensin. </p>
<p>Nopeammasta vastauksesta saa enemmän pisteitä. Väärästä vastauksesta saa kaksinkertaisen määrän miinuspisteitä.</p>
<p>Paina jotain näppäintä aloittaaksesi.</p>

</div>
</div>

<div class="instruction" id="trialinstruction_multi">
<div>
<h1>Select the critical object</h1>
<p>Objects appear from left and right and approach the center. Select with
arrow keys (&#8678; &#8680;) from which side one is first at the center.</p>
<p>The faster you decide, the more points you get. Wrong answer gives double negative points.</p>
<p>Press any key to continue.</p>

<h1>Valitse kriittinen kohde</h1>
<p>Kohteet tulevat vasemmalta ja oikealta ja lähestyvät keskilinjaa. Valitse nuolinäppäimillä (&#8678; &#8680;) kummalla puolella kohde saavuttaa keskilinjan ensin. </p>
<p>Nopeammasta vastauksesta saa enemmän pisteitä. Väärästä vastauksesta saa kaksinkertaisen määrän miinuspisteitä.</p>
<p>Paina jotain näppäintä aloittaaksesi.</p>

</div>
</div>


<div class="instruction" id="trialinstruction_practice">
<div>
<h1>TOPELI 1: Select the critical object, practice rounds</h1>
<p>Objects appear from left and right and approach the center. Select with
arrow keys (&#8678; &#8680;) which one is first at the center.</p>
<p>The faster you decide, the more points you get. Wrong answer gives double negative points.</p>
<p>Press any key to continue.</p>

<h1>TOPELI 1: Valitse kriittinen kohde, harjoituskierros </h1>
<p>Kohteet tulevat vasemmalta ja oikealta ja lähestyvät keskilinjaa. Valitse nuolinäppäimillä (&#8678; &#8680;) kumpi kohde saavuttaa keskilinjan ensin. </p>
<p>Nopeammasta vastauksesta saa enemmän pisteitä. Väärästä vastauksesta saa kaksinkertaisen määrän miinuspisteitä.</p>
<p>Paina jotain näppäintä aloittaaksesi.</p>



</div>
</div>

<div class="instruction" id="forcedstaticinstruction">
<div>
<h1>Select the closest object</h1>
<p>Objects appear to left and right of the centerline and are visible for a moment. Select with
arrow keys (&#8678; &#8680;) which one is closer to the center.</p>
<p>Right answer gives 100 points, wrong answer -200 points.</p>
<p>Press any key to continue.</p>

<h1>Valitse lähin kohde</h1>
<p>Kohteet ilmestyvät vasemmalla ja oikealla keskilinjaa. Ne ovat näkyvissä vain hetken. Valitse 
nuolinäppäimillä (&#8678; &#8680;) kumpi kohde on lähempänä keskilinjaa</p>
<p>Oikeasta vastauksesta 100 pistettä, Väärästä -200 pistettä.</p>
<p>Paina jotain näppäintä aloittaaksesi.</p>

</div>
</div>


<div id="startscreen">
	<form onsubmit="launch_game(); return false;">
	<input type="text" id="name" placeholder="Session id or name" />
	<input type="submit" id="startbutton" value="Start"></button>
	</form>
</div>

<div id="endscreen">
	<div>
	<div>
		Done! Total score <span id="endscore"></span>.
	</div>
	<form onsubmit="location.reload(); return false;">
		<input type="submit" value="Restart"></input>
	</form>
	</div>
</div>
<script type="text/javascript" src="coffeescript.js"></script>
<script type="text/javascript" src="three.js"></script>

<script type="text/coffeescript">

# TODO: dehardcode
WS_LOG_URL = "wss://taupeli.duckdns.org/log/"
POST_LOG_URL = "https://taupeli.duckdns.org/log/"

scene = new THREE.Scene()
camera = new THREE.OrthographicCamera -1, 1, -1, 1, 0.1, 1000
camera.position.z = 5

renderer = new THREE.WebGLRenderer antialias: true
document.body.appendChild renderer.domElement

render = ->
	el = document.body
	w = el.clientWidth
	h = el.clientHeight
	m = Math.min w,h
#	renderer.setSize w, h
	renderer.setSize m, m

#	h = h/w
	h = 1
	w = 1
	camera.left = -w
	camera.right = w
	camera.bottom = -h
	camera.top = h
	camera.updateProjectionMatrix() # May be expensive
	renderer.render scene, camera

NoiseMaterial = new THREE.ShaderMaterial
	transparent: true
	uniforms:
		color: new THREE.Uniform new THREE.Color()
		seed: {'value': 0.0}

	vertexShader: """
	varying vec2 vUv;
	varying vec4 mvPosition;
	varying vec3 local_position;
	void main()
	{
		vUv = uv;
		mvPosition = modelViewMatrix * vec4( position, 1.0 );
		vec4 wPosition = modelMatrix * vec4(position, 1.0);
		gl_Position = projectionMatrix * mvPosition;
		local_position = position;
	}
	"""

	fragmentShader: """
	varying vec3 local_position;
	varying vec2 vUv;
	uniform vec3 color;
	uniform float seed;
	/*float rand(vec2 co){
    		return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
	}*/
	highp float rand(vec2 co)
	{
	    highp float a = 12.9898;
	    highp float b = 78.233;
	    highp float c = 43758.5453;
	    highp float dt= dot(co.xy ,vec2(a,b));
	    highp float sn= mod(dt,3.14);
	    return fract(sin(sn) * c);
	}

	vec3 hsv2rgb(vec3 c)
	{
    		vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    		vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    		return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
	}

	vec3 rgb2hsv(vec3 c)
	{
	    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
	    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

	    float d = q.x - min(q.w, q.y);
	    float e = 1.0e-10;
	    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
	}

	void main() {
		//float value = rand(round(vUv*10.0));
		vec2 pos = vec2(local_position.x + seed/10.0, local_position.y + seed/10.0);
		float value = rand(round(pos*500.0)/500.0);
		
		vec3 hsv = rgb2hsv(color);
		hsv.z = value;
		gl_FragColor = vec4(hsv2rgb(hsv), 1.0);		
	}
	"""

noise_material = ->
	mat = NoiseMaterial.clone()
	mat.color = mat.uniforms.color.value
	return mat

new_object = ->
	geometry = new THREE.SphereGeometry(0.03, 32, 16)
	#material = new THREE.MeshBasicMaterial color: 0xffffff
	material = noise_material()
	object = new THREE.Mesh geometry, material
	scene.add object
	return object

new_mask = ->
	geometry = new THREE.BoxGeometry(3, 0.5, 1)
	material = new THREE.MeshBasicMaterial color: 0xffffff
	mask = new THREE.Mesh geometry, material
	mask.position.z = -100
	scene.add mask
	return mask


background = new THREE.Mesh(
	new THREE.PlaneGeometry(2, 2),
	noise_material()
	)
background.position.z = -10
scene.add background

prev_time = undefined
events_seen = []
document.body.addEventListener("keydown", (ev) -> events_seen.push(ev))
document.body.addEventListener("touchstart", (ev) -> events_seen.push(ev))
next_frame = -> new Promise (resolve, reject) ->
	requestAnimationFrame (time) ->
		prev_time = time
		events = [events_seen...]
		events_seen = []
		resolve([time/1000, events])

pause_rendered = (seconds) ->
	while true
		[time, events] = await next_frame()
		render()
		if not t0?
			t0 = time
		if time - t0 > seconds
			return

reset_events = ->
	events_seen = []

line = new THREE.Line(
	new THREE.BufferGeometry().setFromPoints([
		new THREE.Vector3(0, 1, 0),
		new THREE.Vector3(0, -1, 0)
		]),
	new THREE.LineBasicMaterial
		linewidth: 3
	)
scene.add line

left = new_object()
right = new_object()
left.position.x = -100
right.position.x = 100


left1 = new_object()
right1 = new_object()

left1.position.x = -100
right1.position.x = 100


mask = new_mask()
mask.position.y = -100


total_score = 0
n_trials = 0
update_score = (score) ->
	total_score += score*100
	n_trials += 1
	document.getElementById("score").innerHTML = Math.round(total_score)

display_trial_score = (score) -> 
	background.material.uniforms.seed.value = n_trials
	document.getElementById("trialscore").innerHTML = Math.round(score*100)


get_speeds = ->

	# Randomize uniform ttcdiff 

	abs_max_ttc_diff = 0.5

	min_speed = 0.4
	max_speed = 1.1
	
	abs_ttc_diff = Math.random()*abs_max_ttc_diff
	
	min_t = 1/max_speed
	max_t = 1/min_speed

	ttc_0 = Math.random() * ((max_t-abs_ttc_diff) - min_t) + min_t
	ttc_1 = ttc_0 + abs_ttc_diff
	
	if Math.random() < 0.5
		left_speed = 1/ttc_0
		right_speed = -1/ttc_1
	else
		left_speed = 1/ttc_1
		right_speed = -1/ttc_0

	#	left_speed = (Math.random()*0.15 + 0.5)
	#	right_speed = -(Math.random()*0.15 + 0.5)
	[left_speed, right_speed]




trial = ->
	trialtype = 'base'
	left.position.x = -1
	right.position.x = 1
	
	left.material.color.setHex 0xffffff
	right.material.color.setHex 0xffffff

	[left_speed, right_speed] = get_speeds()

	left_ttc = Math.abs 1/left_speed
	right_ttc = Math.abs 1/right_speed
	
	ttc_diff = right_ttc - left_ttc
	###	
	ttc_diff = Math.random() - 0.5
	right_delay = ttc_diff + left_ttc - right_ttc
	
	if right_delay > 0 
		right.position.x += (right_delay * -right_speed)
		right_ttc = Math.abs right.position.x / right_speed
	else
		left.position.x += right_delay * left_speed
		left_ttc = Math.abs left.position.x / left_speed
	###
	
	min_ttc = Math.min left_ttc, right_ttc

	side_selected = 0
	score = undefined

	t = undefined
	t0 = undefined

	trialinfo =
		type: trialtype
		v0: left_speed
		v1: right_speed
		x0: left.position.x
		x1: right.position.x
		ttcdiff: ttc_diff
		minttc: min_ttc
	


	trialdone = 0
	
	reset_events()
	while true
		[time, events] = await next_frame()
		if not t?
			t = time
			t0 = time
		dt = time - t
		t = time
		for event in events
			# Don't accept keypress unless both objects are visible
			#if Math.abs(right.position.x) > 1 or Math.abs(left.position.x) > 1
			#	break
			if score?
				break
			if event.key == "ArrowLeft" or event.touches?[0].clientX < event.target.clientWidth/2
				side_selected = -1
				left.material.color.setHex 0xff00ff
			else if event.key == "ArrowRight" or event.touches?[0].clientX > event.target.clientWidth/2
				side_selected = 1
				right.material.color.setHex 0xff00ff
			else 
				break
			score = (min_ttc - (t - t0))/min_ttc
			if side_selected == Math.sign(ttc_diff)
				score *= -2
				trialinfo.correct = 0
			else if side_selected == -Math.sign(ttc_diff)
				trialinfo.correct = 1
			trialinfo.reply_ttc_time = min_ttc - (t-t0)
			trialinfo.reply_time = (t-t0)

			update_score(score)
			trialinfo.score = score
			trialinfo.n_trials = n_trials

		left.position.x += left_speed * dt
		right.position.x += right_speed * dt
		
		if left.position.x > 0
			left.position.x = 0
			trialdone = 1
		if right.position.x < 0
			right.position.x = 0
			trialdone = 1
			
		if trialdone
			if not score?
				score = 0
				update_score(score)
				trialinfo.score = score
				trialinfo.n_trials = n_trials
			display_trial_score(score)
			logger(trialinfo)
			return
		
	
		render()
`
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}
`

trial_n_and_n = (left_n, right_n) ->
	[left_speed, right_speed] = get_speeds()

	left_ttc = Math.abs 1/left_speed
	right_ttc = Math.abs 1/right_speed
	ttc_diff = right_ttc - left_ttc
	min_ttc = Math.min left_ttc, right_ttc

	left_primary = new_object()
	left_primary.position.x = -1
	left_primary.speed = left_speed
	left_primary.ttc = -left_primary.position.x/left_speed

	right_primary = new_object()
	right_primary.position.x = 1
	right_primary.speed = right_speed
	right_primary.ttc = -right_primary.position.x/right_speed
	
	object_separation = 0.2
	left_ys = for i in [0...left_n]
		(i - (left_n - 1)/2)*object_separation
	shuffleArray left_ys
	
	left_primary.position.y = left_ys[0]
	left_objects = [left_primary]
	for i in [1...left_n]
		obj = new_object()
		obj.position.x = -1
		obj.position.y = left_ys[i]
		obj.speed = left_speed - Math.random()*0.3
		left_objects.push obj

	right_ys = for i in [0...right_n]
		(i - (right_n - 1)/2)*object_separation
	shuffleArray right_ys
	
	right_primary.position.y = right_ys[0]
	right_objects = [right_primary]
	for i in [1...right_n]
		obj = new_object()
		obj.position.x = 1
		obj.position.y = right_ys[i]
		obj.speed = right_speed + Math.random()*0.3
		right_objects.push obj
	
	objects = left_objects.concat right_objects

	trialdone = 0
	trialinfo =
		type: "base_n_by_n"
		left_n: left_n
		right_n: right_n
		ttc_diff: ttc_diff
		min_ttc: min_ttc
		objects: for obj in objects
			x: obj.position.x
			y: obj.position.y
			speed: obj.speed
	
	reset_events()
	time0 = undefined
	while true
		[time, events] = await next_frame()
		if not time0?
			time0 = time
			prev_t = time - time0
		t = time - time0
		dt = t - prev_t
		prev_t = t

		for event in events
			if score?
				break
			if event.key == "ArrowLeft" or event.touches?[0].clientX < event.target.clientWidth/2
				side_selected = -1
				for obj in left_objects
					obj.material.color.setHex 0xff00ff
			else if event.key == "ArrowRight" or event.touches?[0].clientX > event.target.clientWidth/2
				side_selected = 1
				for obj in right_objects
					obj.material.color.setHex 0xff00ff
			else 
				break
			score = (min_ttc - t)/min_ttc
			if side_selected == Math.sign(ttc_diff)
				score *= -2
				trialinfo.correct = 0
			else if side_selected == -Math.sign(ttc_diff)
				trialinfo.correct = 1

			trialinfo.side_selected = side_selected
			trialinfo.reply_ttc_time = min_ttc - t
			trialinfo.reply_time = t
			
			update_score(score)
			trialinfo.score = score
			trialinfo.n_trials = n_trials

		for obj in objects
			obj.position.x += obj.speed*dt
		
		if left_primary.position.x > 0 or right_primary.position.x < 0
			trialdone = 1

		if trialdone
			if not score?
				score = 0
				update_score score
				trialinfo.score = score
				trialinfo.n_trials = n_trials
			display_trial_score score
			logger trialinfo
			break

		render()
	
	for obj in objects
		scene.remove obj


trial_two_and_one = ->
	trialtype = 'base_two_and_one'
	answertime = 0
	mask.position.y=100

	left.position.x = -1   
	right.position.x = 1 
	left.position.y = 0
	right.position.y = 0
	
	left.material.color.setHex 0xffffff
	right.material.color.setHex 0xffffff
	left1.material.color.setHex 0xffffff
	right1.material.color.setHex 0xffffff

	[left_speed, right_speed] = get_speeds()

		
	left_ttc = Math.abs (left.position.x)/left_speed
	right_ttc = Math.abs (right.position.x)/right_speed
	
	ttc_diff = right_ttc - left_ttc



	if Math.random() < 0.5
	# add extra ball
		left1_speed = left_speed - Math.random()*0.3
		left1.position.x = -1
		if Math.random() < 0.5
			left1.position.y = 0.1
			left.position.y = -0.1
		else
			left1.position.y = -0.1
			left.position.y = 0.1
	else
		right1_speed = right_speed + Math.random()*0.3
		right1.position.x = 1
		if Math.random() < 0.5
			right1.position.y = 0.1
			right.position.y = -0.1
		else
			right1.position.y = -0.1
			right.position.y = 0.1

	
	min_ttc = Math.min left_ttc, right_ttc
	side_selected = 0
	score = undefined

	t = undefined
	t0 = undefined

	trialinfo =
		type: trialtype
		v0: left_speed
		v1: right_speed
		x0: left.position.x
		x1: right.position.x
		v2: left1_speed
		x2: left1.position.x
		v3: right1_speed
		x3: right1.position.x
		y2: left1.position.y
		y3: right1.position.y
	
		ttcdiff: ttc_diff
		minttc: min_ttc


	trialdone = 0
	reset_events()
	while true
		[time, events] = await next_frame()
		if not t?
			t = time
			t0 = time
		dt = time - t
		t = time
		for event in events
			if score?
				break
			if event.key == "ArrowLeft" or event.touches?[0].clientX < event.target.clientWidth/2
				side_selected = -1
				left.material.color.setHex 0xff00ff
				left1.material.color.setHex 0xff00ff
			else if event.key == "ArrowRight" or event.touches?[0].clientX > event.target.clientWidth/2
				side_selected = 1
				right.material.color.setHex 0xff00ff
				right1.material.color.setHex 0xff00ff
			else
				break
			score = (min_ttc - (t - t0))/min_ttc
			if side_selected == Math.sign(ttc_diff)
				score *= -2
				trialinfo.correct = 0
			else if side_selected == -Math.sign(ttc_diff)
				trialinfo.correct = 1
			trialinfo.reply_ttc_time = min_ttc - (t-t0)
			trialinfo.reply_time = (t-t0)

			update_score(score)
			trialinfo.score = score
			trialinfo.n_trials = n_trials
		
		left.position.x += left_speed * dt
		left1.position.x += left1_speed * dt
		right.position.x += right_speed * dt
		right1.position.x += right1_speed * dt
		
		if left.position.x > 0
			left.position.x = 0
			trialdone = 1
		if right.position.x < 0
			right.position.x = 0
			trialdone = 1
			
		if trialdone
			if not score?
				score = 0
				update_score(score)
				trialinfo.score = score
				trialinfo.n_trials = n_trials
			display_trial_score(score)
			logger(trialinfo)
			return
		
	
		render()



trial_flash_forced = ->
	trialtype = 'flash_forced'
	answertime = 0
	left.position.x = -1
	right.position.x = 1
	
	left.material.color.setHex 0xffffff
	right.material.color.setHex 0xffffff

	[left_speed, right_speed] = get_speeds()
	
	left_ttc = Math.abs 1/left_speed
	right_ttc = Math.abs 1/right_speed
	
	ttc_diff = right_ttc - left_ttc
	###	
	ttc_diff = Math.random() - 0.5
	right_delay = ttc_diff + left_ttc - right_ttc
	
	if right_delay > 0 
		right.position.x += (right_delay * -right_speed)
		right_ttc = Math.abs right.position.x / right_speed
	else
		left.position.x += right_delay * left_speed
		left_ttc = Math.abs left.position.x / left_speed
	###
	
	min_ttc = Math.min left_ttc, right_ttc
	disappearlocation = Math.random()*0.5 + 0.4

	side_selected = 0
	score = undefined

	t = undefined
	t0 = undefined

	trialinfo =
		type: trialtype
		v0: left_speed
		v1: right_speed
		x0: left.position.x
		x1: right.position.x
		ttcdiff: ttc_diff
		minttc: min_ttc
		disappear: disappearlocation

	


	trialdone = 0
	
	reset_events()
	while true
		[time, events] = await next_frame()
		if not t?
			t = time
			t0 = time
		dt = time - t
		t = time
		for event in events
			# Don't accept keypress unless both objects are visible
			#if Math.abs(right.position.x) > 1 or Math.abs(left.position.x) > 1
			if not answertime
				break
			if score?
				break
			if event.key == "ArrowLeft" or event.touches?[0].clientX < event.target.clientWidth/2
				side_selected = -1
				left.material.color.setHex 0xff00ff
				trialdone = 1
			else if event.key == "ArrowRight" or event.touches?[0].clientX > event.target.clientWidth/2
				side_selected = 1
				right.material.color.setHex 0xff00ff
				trialdone = 1
			else
				break
			#score = (min_ttc - (t - t0))/min_ttc
			score = 1
			if side_selected == Math.sign(ttc_diff)
				score *= -2
				trialinfo.correct = 0
			else if side_selected == -Math.sign(ttc_diff)
				trialinfo.correct = 1
			trialinfo.reply_ttc_time = min_ttc - (t-t0)
			trialinfo.reply_time = (t-t0)

			update_score(score)
			trialinfo.score = score
			trialinfo.n_trials = n_trials

		
		if left.position.x > 0-disappearlocation || right.position.x < 0+disappearlocation 
			left.position.x = -100
			right.position.x = 100
			left_speed = 0
			right_speed = 0
			answertime = 1
			document.getElementById("answerprompt").innerHTML = 'which one first at the center <br>  &#8678; press an arrow key &#8680; '
			
		else
			left.position.x += left_speed * dt
			right.position.x += right_speed * dt
		


		if left.position.x > 0
			left.position.x = 0
			trialdone = 1
		if right.position.x < 0
			right.position.x = 0
			trialdone = 1
			
		if trialdone
			if not score?
				score = 0
				update_score(score)
				trialinfo.score = score
				trialinfo.n_trials = n_trials
			display_trial_score(score)
			logger(trialinfo)
			return
		
	
		render()



trial_flash_nonforced = ->
	trialtype = 'flash_nonforced'
	answertime = 0
	left.position.x = -1
	right.position.x = 1
	
	left.material.color.setHex 0xffffff
	right.material.color.setHex 0xffffff


	[left_speed, right_speed] = get_speeds()
	
	left_ttc = Math.abs 1/left_speed
	right_ttc = Math.abs 1/right_speed
	
	ttc_diff = right_ttc - left_ttc
	###	
	ttc_diff = Math.random() - 0.5
	right_delay = ttc_diff + left_ttc - right_ttc
	
	if right_delay > 0 
		right.position.x += (right_delay * -right_speed)
		right_ttc = Math.abs right.position.x / right_speed
	else
		left.position.x += right_delay * left_speed
		left_ttc = Math.abs left.position.x / left_speed
	###
	
	min_ttc = Math.min left_ttc, right_ttc
	disappearlocation = Math.random()*0.5 + 0.4

	side_selected = 0
	score = undefined

	t = undefined
	t0 = undefined

	trialinfo =
		type: trialtype
		v0: left_speed
		v1: right_speed
		x0: left.position.x
		x1: right.position.x
		ttcdiff: ttc_diff
		minttc: min_ttc
		disappear: disappearlocation

	


	trialdone = 0
	
	reset_events()
	while true
		[time, events] = await next_frame()
		if not t?
			t = time
			t0 = time
		dt = time - t
		t = time
		for event in events
			# Don't accept keypress unless both objects are visible
			#if Math.abs(right.position.x) > 1 or Math.abs(left.position.x) > 1
			if not answertime
				break
			if score?
				break
			if event.key == "ArrowLeft" or event.touches?[0].clientX < event.target.clientWidth/2
				side_selected = -1
				left.material.color.setHex 0xff00ff
				trialdone = 1
			else if event.key == "ArrowRight" or event.touches?[0].clientX > event.target.clientWidth/2
				side_selected = 1
				right.material.color.setHex 0xff00ff
				trialdone = 1
			else if event.key == "ArrowDown" 
				side_selected = 0
				right.material.color.setHex 0xff00ff
				trialdone = 1
				trialinfo.correct = 2
				score = 0
			else
				break
			#score = (min_ttc - (t - t0))/min_ttc
		
			if side_selected == Math.sign(ttc_diff)
				score = -2
				trialinfo.correct = 0
			else if side_selected == -Math.sign(ttc_diff)
				trialinfo.correct = 1
				score = 1
			trialinfo.reply_ttc_time = min_ttc - (t-t0)
			trialinfo.reply_time = (t-t0)

			update_score(score)
			trialinfo.score = score
			trialinfo.n_trials = n_trials

		
		if left.position.x > 0-disappearlocation || right.position.x < 0+disappearlocation 
			left.position.x = -100
			right.position.x = 100
			left_speed = 0
			right_speed = 0
			answertime = 1
			document.getElementById("answerprompt").innerHTML = 'which one first at the center <br>  &#8678; press arrow key &#8680; <br> or &#8681; to pass '
		else
			left.position.x += left_speed * dt
			right.position.x += right_speed * dt
		


		if left.position.x > 0
			left.position.x = 0
			trialdone = 1
		if right.position.x < 0
			right.position.x = 0
			trialdone = 1
			
		if trialdone
			if not score?
				score = 0
				update_score(score)
				trialinfo.score = score
				trialinfo.n_trials = n_trials
			display_trial_score(score)
			logger(trialinfo)
			return
		
	
		render()

static_flash_forced = ->
	trialtype = 'static_flash_forced'
	answertime = 0
	
	
	left.material.color.setHex 0xffffff
	right.material.color.setHex 0xffffff
	
	maxdiff = 0.1
	min_dur = 1/30
	max_dur = 0.3
	wait_dur = 0.5

	minpos = 1 - maxdiff*2
	maxpos = maxdiff*2
	
	posdiff = (Math.random() - 0.5)*2*maxdiff
	duration = Math.random()*(max_dur - min_dur) + min_dur

	right_pos = Math.random()*(maxpos - minpos) + minpos
	left_pos = -right_pos + posdiff

	left.position.x = -100
	right.position.x = 100


	trialinfo =
		type: trialtype
		x0: left_pos
		x1: right_pos
		posdiff: posdiff
		duration: duration

	


	trialdone = 0
	
	reset_events()
	while true
		[time, events] = await next_frame()
		if not t?
			t = time
			t0 = time
		dt = time - t
		t = time
		for event in events
			# Don't accept keypress unless both objects are visible
			#if Math.abs(right.position.x) > 1 or Math.abs(left.position.x) > 1
			if not answertime
				break
			if score?
				break
			if event.key == "ArrowLeft" or event.touches?[0].clientX < event.target.clientWidth/2
				side_selected = -1
				left.material.color.setHex 0xff00ff
				trialdone = 1
			else if event.key == "ArrowRight" or event.touches?[0].clientX > event.target.clientWidth/2
				side_selected = 1
				right.material.color.setHex 0xff00ff
				trialdone = 1
			else
				break
			#score = (min_ttc - (t - t0))/min_ttc
			score = 1
			if side_selected == Math.sign(posdiff)
				score *= -2
				trialinfo.correct = 0
			else if side_selected == -Math.sign(posdiff)
				trialinfo.correct = 1
			trialinfo.reply_time = (t-t0)

			update_score(score)
			trialinfo.score = score
			trialinfo.n_trials = n_trials

		if t - t0 > duration + wait_dur and not answertime
			left.position.x = -100
			right.position.x = 100
			answertime = 1
			trialinfo.hidetime = t - t0
			document.getElementById("answerprompt").innerHTML = 'which one closer to the center <br>  &#8678; press an arrow key &#8680; '
		else if t - t0 > wait_dur and not answertime
			left.position.x = left_pos
			right.position.x = right_pos
			trialinfo.showtime = t - t0
		
		if trialdone
			if not score?
				score = 0
				update_score(score)
				trialinfo.score = score
				trialinfo.n_trials = n_trials
			display_trial_score(score)
			logger(trialinfo)
			return
		
	
		render()


trial_flash_forced_random_startloc = ->
	trialtype = 'flash_forced'
	answertime = 0
	left.position.x = -1 + Math.random()*0.2
	right.position.x = 1 - Math.random()*0.2
	
	left.material.color.setHex 0xffffff
	right.material.color.setHex 0xffffff

	[left_speed, right_speed] = get_speeds()
	
	
	left_ttc = Math.abs (left.position.x)/left_speed
	right_ttc = Math.abs (right.position.x)/right_speed
	
	ttc_diff = right_ttc - left_ttc
	###	
	ttc_diff = Math.random() - 0.5
	right_delay = ttc_diff + left_ttc - right_ttc
	
	if right_delay > 0 
		right.position.x += (right_delay * -right_speed)
		right_ttc = Math.abs right.position.x / right_speed
	else
		left.position.x += right_delay * left_speed
		left_ttc = Math.abs left.position.x / left_speed
	###
	
	min_ttc = Math.min left_ttc, right_ttc
	disappearlocation = Math.random()*0.5 + 0.2

	side_selected = 0
	score = undefined

	t = undefined
	t0 = undefined

	trialinfo =
		type: trialtype
		v0: left_speed
		v1: right_speed
		x0: left.position.x
		x1: right.position.x
		ttcdiff: ttc_diff
		minttc: min_ttc
		disappear: disappearlocation

	


	trialdone = 0
	
	reset_events()
	while true
		[time, events] = await next_frame()
		if not t?
			t = time
			t0 = time
		dt = time - t
		t = time
		for event in events
			# Don't accept keypress unless both objects are visible
			#if Math.abs(right.position.x) > 1 or Math.abs(left.position.x) > 1
			if not answertime
				break
			if score?
				break
			if event.key == "ArrowLeft" or event.touches?[0].clientX < event.target.clientWidth/2
				side_selected = -1
				left.material.color.setHex 0xff00ff
				trialdone = 1
			else if event.key == "ArrowRight" or event.touches?[0].clientX > event.target.clientWidth/2
				side_selected = 1
				right.material.color.setHex 0xff00ff
				trialdone = 1
			else
				break
			#score = (min_ttc - (t - t0))/min_ttc
			score = 1
			if side_selected == Math.sign(ttc_diff)
				score *= -2
				trialinfo.correct = 0
			else if side_selected == -Math.sign(ttc_diff)
				trialinfo.correct = 1
			trialinfo.reply_ttc_time = min_ttc - (t-t0)
			trialinfo.reply_time = (t-t0)

			update_score(score)
			trialinfo.score = score
			trialinfo.n_trials = n_trials

		
		if left.position.x > 0-disappearlocation || right.position.x < 0+disappearlocation 
			left.position.x = -100
			right.position.x = 100
			left_speed = 0
			right_speed = 0
			answertime = 1
			document.getElementById("answerprompt").innerHTML = 'which one first at the center <br>  &#8678; press an arrow key &#8680; '
			
		else
			left.position.x += left_speed * dt
			right.position.x += right_speed * dt
		


		if left.position.x > 0
			left.position.x = 0
			trialdone = 1
		if right.position.x < 0
			right.position.x = 0
			trialdone = 1
			
		if trialdone
			if not score?
				score = 0
				update_score(score)
				trialinfo.score = score
				trialinfo.n_trials = n_trials
			display_trial_score(score)
			logger(trialinfo)
			return
		
	
		render()

trial_flash_forced_random_startloc_masked = ->
	trialtype = 'flash_forced'
	answertime = 0
	mask.position.y=100

	left.position.x = -1 + Math.random()*0.2
	right.position.x = 1 - Math.random()*0.2
	
	left.material.color.setHex 0xffffff
	right.material.color.setHex 0xffffff

	[left_speed, right_speed] = get_speeds()
	
	
	left_ttc = Math.abs (left.position.x)/left_speed
	right_ttc = Math.abs (right.position.x)/right_speed
	
	ttc_diff = right_ttc - left_ttc
	###	
	ttc_diff = Math.random() - 0.5
	right_delay = ttc_diff + left_ttc - right_ttc
	
	if right_delay > 0 
		right.position.x += (right_delay * -right_speed)
		right_ttc = Math.abs right.position.x / right_speed
	else
		left.position.x += right_delay * left_speed
		left_ttc = Math.abs left.position.x / left_speed
	###
	
	min_ttc = Math.min left_ttc, right_ttc
	disappearlocation = Math.random()*0.5 + 0.2

	side_selected = 0
	score = undefined

	t = undefined
	t0 = undefined

	trialinfo =
		type: trialtype
		v0: left_speed
		v1: right_speed
		x0: left.position.x
		x1: right.position.x
		ttcdiff: ttc_diff
		minttc: min_ttc
		disappear: disappearlocation

	


	trialdone = 0
	
	reset_events()
	while true
		[time, events] = await next_frame()
		if not t?
			t = time
			t0 = time
		dt = time - t
		t = time
		for event in events
			# Don't accept keypress unless both objects are visible
			#if Math.abs(right.position.x) > 1 or Math.abs(left.position.x) > 1
			if (not answertime) or (mask.position.y == 0)
				break
			if score?
				break
			if event.key == "ArrowLeft" or event.touches?[0].clientX < event.target.clientWidth/2
				side_selected = -1
				left.material.color.setHex 0xff00ff
				trialdone = 1
			else if event.key == "ArrowRight" or event.touches?[0].clientX > event.target.clientWidth/2
				side_selected = 1
				right.material.color.setHex 0xff00ff
				trialdone = 1
			else
				break
			#score = (min_ttc - (t - t0))/min_ttc
			score = 1
			if side_selected == Math.sign(ttc_diff)
				score *= -2
				trialinfo.correct = 0
			else if side_selected == -Math.sign(ttc_diff)
				trialinfo.correct = 1
			trialinfo.reply_ttc_time = min_ttc - (t-t0)
			trialinfo.reply_time = (t-t0)

			update_score(score)
			trialinfo.score = score
			trialinfo.n_trials = n_trials

		
		if left.position.x > 0-disappearlocation || right.position.x < 0+disappearlocation 
			left.position.x = -100
			right.position.x = 100
			left_speed = 0
			right_speed = 0
			mask.position.y = 0	
			setTimeout (-> mask.position.y=100 ), 300

			answertime = 1
			document.getElementById("answerprompt").innerHTML = 'which one first at the center <br>  &#8678; press an arrow key &#8680; '
			
		else
			left.position.x += left_speed * dt
			right.position.x += right_speed * dt
		


		if left.position.x > 0
			left.position.x = 0
			trialdone = 1
		if right.position.x < 0
			right.position.x = 0
			trialdone = 1
			
		if trialdone
			if not score?
				score = 0
				update_score(score)
				trialinfo.score = score
				trialinfo.n_trials = n_trials
			display_trial_score(score)
			logger(trialinfo)
			return
		
	
		render()

trial_flash_forced_masked_one_and_one = ->
	trialtype = 'flash_forced_masked_one_and_one'
	answertime = 0
	mask.position.y=100

	left.position.x = -1   
	right.position.x = 1 
	left.position.y = 0
	right.position.y = 0
	
	left.material.color.setHex 0xffffff
	right.material.color.setHex 0xffffff

	[left_speed, right_speed] = get_speeds()
	
	
	left_ttc = Math.abs (left.position.x)/left_speed
	right_ttc = Math.abs (right.position.x)/right_speed
	
	ttc_diff = right_ttc - left_ttc
	###	
	ttc_diff = Math.random() - 0.5
	right_delay = ttc_diff + left_ttc - right_ttc
	
	if right_delay > 0 
		right.position.x += (right_delay * -right_speed)
		right_ttc = Math.abs right.position.x / right_speed
	else
		left.position.x += right_delay * left_speed
		left_ttc = Math.abs left.position.x / left_speed
	###
	
	min_ttc = Math.min left_ttc, right_ttc
	#disappearlocation = Math.random()*0.5 + 0.2
	disappeartime = Math.random()*0.4 + 0.4
	side_selected = 0
	score = undefined

	t = undefined
	t0 = undefined

	trialinfo =
		type: trialtype
		v0: left_speed
		v1: right_speed
		x0: left.position.x
		x1: right.position.x
		ttcdiff: ttc_diff
		minttc: min_ttc
		disappear: disappeartime

	


	trialdone = 0
	
	reset_events()
	while true
		[time, events] = await next_frame()
		if not t?
			t = time
			t0 = time
		dt = time - t
		t = time
		for event in events
			# Don't accept keypress unless both objects are visible
			#if Math.abs(right.position.x) > 1 or Math.abs(left.position.x) > 1
			if (not answertime) or (mask.position.y == 0)
				break
			if score?
				break
			if event.key == "ArrowLeft" or event.touches?[0].clientX < event.target.clientWidth/2
				side_selected = -1
				left.material.color.setHex 0xff00ff
				trialdone = 1
			else if event.key == "ArrowRight" or event.touches?[0].clientX > event.target.clientWidth/2
				side_selected = 1
				right.material.color.setHex 0xff00ff
				trialdone = 1
			else
				break
			#score = (min_ttc - (t - t0))/min_ttc
			score = 1
			if side_selected == Math.sign(ttc_diff)
				score *= -2
				trialinfo.correct = 0
			else if side_selected == -Math.sign(ttc_diff)
				trialinfo.correct = 1
			trialinfo.reply_ttc_time = min_ttc - (t-t0)
			trialinfo.reply_time = (t-t0)

			update_score(score)
			trialinfo.score = score
			trialinfo.n_trials = n_trials

		
		#if left.position.x > 0-disappearlocation || right.position.x < 0+disappearlocation 
		if ((t-t0) > disappeartime) and (not answertime)
			left.position.x = -100
			right.position.x = 100
			left_speed = 0
			right_speed = 0
			mask.position.y = 0	
			setTimeout (-> mask.position.y=100 ), 300

			answertime = 1
			document.getElementById("answerprompt").innerHTML = 'which side faster <br>  &#8678; press an arrow key &#8680; '
			
		else
			left.position.x += left_speed * dt
			right.position.x += right_speed * dt
		


		if left.position.x > 0
			left.position.x = 0
			trialdone = 1
		if right.position.x < 0
			right.position.x = 0
			trialdone = 1
			
		if trialdone
			if not score?
				score = 0
				update_score(score)
				trialinfo.score = score
				trialinfo.n_trials = n_trials
			display_trial_score(score)
			logger(trialinfo)
			return
		
	
		render()


trial_flash_forced_masked_two_and_one = ->
	trialtype = 'flash_forced_masked_two_and_one'
	answertime = 0
	mask.position.y=100

	left.position.x = -1   
	right.position.x = 1 
	left.position.y = 0
	right.position.y = 0
	
	left.material.color.setHex 0xffffff
	right.material.color.setHex 0xffffff

	[left_speed, right_speed] = get_speeds()

		
	left_ttc = Math.abs (left.position.x)/left_speed
	right_ttc = Math.abs (right.position.x)/right_speed
	
	ttc_diff = right_ttc - left_ttc



	if Math.random() < 0.5
	# add extra ball
		left1_speed = left_speed - Math.random()*0.3
		left1.position.x = -1
		if Math.random() < 0.5
			left1.position.y = 0.1
			left.position.y = -0.1
		else
			left1.position.y = -0.1
			left.position.y = 0.1
	else
		right1_speed = right_speed + Math.random()*0.3
		right1.position.x = 1
		if Math.random() < 0.5
			right1.position.y = 0.1
			right.position.y = -0.1
		else
			right1.position.y = -0.1
			right.position.y = 0.1

	
	min_ttc = Math.min left_ttc, right_ttc
	#disappearlocation = Math.random()*0.5 + 0.2
	disappeartime = Math.random()*0.4 + 0.4
	side_selected = 0
	score = undefined

	t = undefined
	t0 = undefined

	trialinfo =
		type: trialtype
		v0: left_speed
		v1: right_speed
		x0: left.position.x
		x1: right.position.x
		v2: left1_speed
		x2: left1.position.x
		v3: right1_speed
		x3: right1.position.x
		y2: left1.position.y
		y3: right1.position.y
	
		ttcdiff: ttc_diff
		minttc: min_ttc
		disappear: disappeartime


	trialdone = 0
	reset_events()
	while true
		[time, events] = await next_frame()
		if not t?
			t = time
			t0 = time
		dt = time - t
		t = time
		for event in events
			# Don't accept keypress unless both objects are visible
			#if Math.abs(right.position.x) > 1 or Math.abs(left.position.x) > 1
			if (not answertime) or (mask.position.y == 0)
				break
			if score?
				break
			if event.key == "ArrowLeft" or event.touches?[0].clientX < event.target.clientWidth/2
				side_selected = -1
				left.material.color.setHex 0xff00ff
				trialdone = 1
			else if event.key == "ArrowRight" or event.touches?[0].clientX > event.target.clientWidth/2
				side_selected = 1
				right.material.color.setHex 0xff00ff
				trialdone = 1
			else
				break
			#score = (min_ttc - (t - t0))/min_ttc
			score = 1
			if side_selected == Math.sign(ttc_diff)
				score *= -2
				trialinfo.correct = 0
			else if side_selected == -Math.sign(ttc_diff)
				trialinfo.correct = 1
			trialinfo.reply_ttc_time = min_ttc - (t-t0)
			trialinfo.reply_time = (t-t0)

			update_score(score)
			trialinfo.score = score
			trialinfo.n_trials = n_trials

		
		#if left.position.x > 0-disappearlocation || right.position.x < 0+disappearlocation
		if ((t-t0) > disappeartime) and (not answertime)
			left.position.x = -100
			right.position.x = 100
			left1.position.x = -100
			right1.position.x = 100
			left_speed = 0
			right_speed = 0
			left1_speed = 0
			right1_speed = 0
			mask.position.y = 0	
			setTimeout (-> mask.position.y=100 ), 300

			answertime = 1
			document.getElementById("answerprompt").innerHTML = 'which side faster <br>  &#8678; press an arrow key &#8680; '
			
		else
			left.position.x += left_speed * dt
			right.position.x += right_speed * dt
			left1.position.x += left1_speed * dt
			right1.position.x += right1_speed * dt
					


		if left.position.x > 0
			left.position.x = 0
			trialdone = 1
		if right.position.x < 0
			right.position.x = 0
			trialdone = 1
			
		if trialdone
			if not score?
				score = 0
				update_score(score)
				trialinfo.score = score
				trialinfo.n_trials = n_trials
			display_trial_score(score)
			logger(trialinfo)
			return
		
	
		render()

trial_corners_forced = ->
	trialtype = 'trial_corners_forced'
	answertime = 0
	mask.position.y=100

	cond_list = [12,23,34,41]
	condition = cond_list[Math.floor(Math.random()*cond_list.length)]
	console.log condition

	[left_speed, right_speed] = get_speeds()
	right_speed = Math.abs(right_speed)

	switch condition
		when 12 
			left.position.x = -1   
			right.position.x = 1 
			left.position.y = 1
			right.position.y = 1
			left_speed_x = left_speed
			right_speed_x = -right_speed
			left_speed_y = -left_speed
			right_speed_y = -right_speed
			left_key = "ArrowLeft" 
			right_key = "ArrowRight"
		when 23
			left.position.x = -1   
			right.position.x = -1 
			left.position.y = 1
			right.position.y = -1
			left_speed_x = left_speed
			right_speed_x = right_speed
			left_speed_y = -left_speed
			right_speed_y = right_speed
			left_key = "ArrowUp" 
			right_key = "ArrowDown"


		when 34
			left.position.x = -1   
			right.position.x = 1 
			left.position.y = -1
			right.position.y = -1
			left_speed_x = left_speed
			right_speed_x = -right_speed
			left_speed_y = left_speed
			right_speed_y = right_speed
			left_key = "ArrowLeft" 
			right_key = "ArrowRight"


		when 41
			left.position.x = 1   
			right.position.x = 1 
			left.position.y = 1
			right.position.y = -1
			left_speed_x = -left_speed
			right_speed_x = -right_speed
			left_speed_y = -left_speed
			right_speed_y = right_speed
			left_key = "ArrowUp" 
			right_key = "ArrowDown"

		
	left.material.color.setHex 0xffffff
	right.material.color.setHex 0xffffff

	left_ttc = Math.abs (left.position.x)/left_speed
	right_ttc = Math.abs (right.position.x)/right_speed
	
	ttc_diff = right_ttc - left_ttc

	
	###	
	ttc_diff = Math.random() - 0.5
	right_delay = ttc_diff + left_ttc - right_ttc
	
	if right_delay > 0 
		right.position.x += (right_delay * -right_speed)
		right_ttc = Math.abs right.position.x / right_speed
	else
		left.position.x += right_delay * left_speed
		left_ttc = Math.abs left.position.x / left_speed
	###
	
	min_ttc = Math.min left_ttc, right_ttc
	#disappearlocation = Math.random()*0.5 + 0.2
	disappeartime = Math.random()*0.4 + 0.4
	side_selected = 0
	score = undefined

	t = undefined
	t0 = undefined

	trialinfo =
		type: trialtype
		v0: left_speed
		v1: right_speed
		x0: left.position.x
		x1: right.position.x
		condition: condition
		ttcdiff: ttc_diff
		minttc: min_ttc
		disappear: disappeartime

	


	trialdone = 0
	
	reset_events()
	while true
		[time, events] = await next_frame()
		if not t?
			t = time
			t0 = time
		dt = time - t
		t = time
		for event in events
			# Don't accept keypress unless both objects are visible
			#if Math.abs(right.position.x) > 1 or Math.abs(left.position.x) > 1
			if (not answertime) or (mask.position.y == 0)
				break
			if score?
				break
			if event.key == left_key or event.touches?[0].clientX < event.target.clientWidth/2
				side_selected = -1
				left.material.color.setHex 0xff00ff
				trialdone = 1
			else if event.key == right_key or event.touches?[0].clientX > event.target.clientWidth/2
				side_selected = 1
				right.material.color.setHex 0xff00ff
				trialdone = 1
			else
				break
			#score = (min_ttc - (t - t0))/min_ttc
			score = 1
			if side_selected == Math.sign(ttc_diff)
				score *= -2
				trialinfo.correct = 0
			else if side_selected == -Math.sign(ttc_diff)
				trialinfo.correct = 1
			trialinfo.reply_ttc_time = min_ttc - (t-t0)
			trialinfo.reply_time = (t-t0)

			update_score(score)
			trialinfo.score = score
			trialinfo.n_trials = n_trials

		
		#if left.position.x > 0-disappearlocation || right.position.x < 0+disappearlocation 
		if ((t-t0) > disappeartime) and (not answertime)
			left.position.x = -100
			right.position.x = 100
			left_speed = 0
			right_speed = 0
			mask.position.y = 0	
			setTimeout (-> mask.position.y=100 ), 300

			answertime = 1
			#document.getElementById("answerprompt").innerHTML = 'which side faster <br>  &#8678; press an arrow key &#8680; '
			
		else
			left.position.x += left_speed_x * dt
			right.position.x += right_speed_x * dt
			left.position.y += left_speed_y * dt
			right.position.y += right_speed_y * dt
		


		# if left.position.x > 0
		# 	left.position.x = 0
		# 	trialdone = 1
		# if right.position.x < 0
		# 	right.position.x = 0
		# 	trialdone = 1
			
		if trialdone
			if not score?
				score = 0
				update_score(score)
				trialinfo.score = score
				trialinfo.n_trials = n_trials
			display_trial_score(score)
			logger(trialinfo)
			return
		
	
		render()


show_instruction = (id) ->
	el = document.getElementById id
	el.style.display = "flex"
	new Promise (accept) ->
		do_accept = ->
			el.style.display = "none"
			accept()
		document.body.addEventListener "keyup", do_accept
		el.addEventListener "click", do_accept

start_game = ->
	max_blocks = 1
	max_trials = 25
	
	for b in [0...max_blocks]
		await show_instruction "forcedinstruction_practice"
		for i in [0...max_trials]
			document.getElementById("trial_n").innerHTML = "#{i+1} / #{max_trials}"
			document.getElementById("trialscore").innerHTML = ""
			document.getElementById("answerprompt").innerHTML = ""		
			await trial_flash_forced_masked_one_and_one()
			#await trial_corners_forced()
			await new Promise (a) -> setTimeout a, 1000
		document.getElementById("trial_n").innerHTML = ""
		document.getElementById("trialscore").innerHTML = ""
		document.getElementById("answerprompt").innerHTML = ""
	
		await show_instruction "forced_two_and_one_instruction_practice"
		for i in [0...max_trials]
			document.getElementById("trial_n").innerHTML = "#{i+1} / #{max_trials}"
			document.getElementById("trialscore").innerHTML = ""
			document.getElementById("answerprompt").innerHTML = ""
			await trial_flash_forced_masked_two_and_one()
			await new Promise (a) -> setTimeout a, 1000
		document.getElementById("trial_n").innerHTML = ""
		document.getElementById("trialscore").innerHTML = ""
		document.getElementById("answerprompt").innerHTML = ""
		

	total_score = 0
		
	max_blocks = 3
	max_trials = 75

	for b in [0...max_blocks]
		await show_instruction "forcedinstruction"
		for i in [0...max_trials]
			document.getElementById("trial_n").innerHTML = "#{i+1} / #{max_trials}"
			document.getElementById("trialscore").innerHTML = ""
			document.getElementById("answerprompt").innerHTML = ""		
			await trial_flash_forced_masked_one_and_one()
			await new Promise (a) -> setTimeout a, 1000
		document.getElementById("trial_n").innerHTML = ""
		document.getElementById("trialscore").innerHTML = ""
		document.getElementById("answerprompt").innerHTML = ""
	
		await show_instruction "forced_two_and_one_instruction"
		for i in [0...max_trials]
			document.getElementById("trial_n").innerHTML = "#{i+1} / #{max_trials}"
			document.getElementById("trialscore").innerHTML = ""
			document.getElementById("answerprompt").innerHTML = ""
			await trial_flash_forced_masked_two_and_one()
			await new Promise (a) -> setTimeout a, 1000
		document.getElementById("trial_n").innerHTML = ""
		document.getElementById("trialscore").innerHTML = ""
		document.getElementById("answerprompt").innerHTML = ""
			

start_static_game = ->
	await show_instruction "forcedstaticinstruction"
	for i in [0...100]
		document.getElementById("trialscore").innerHTML = ""
		document.getElementById("answerprompt").innerHTML = ""

		await static_flash_forced()
		await new Promise (a) -> setTimeout a, 1000

	document.getElementById("trialscore").innerHTML = ""
	document.getElementById("answerprompt").innerHTML = ""

start_corner_game = ->
	#await show_instruction "forcedstaticinstruction"
	for i in [0...250]
		document.getElementById("trialscore").innerHTML = ""
		document.getElementById("answerprompt").innerHTML = ""

		await new Promise (a) -> setTimeout a, 300
		await trial_corners_forced()
		await new Promise (a) -> setTimeout a, 1000

	document.getElementById("trialscore").innerHTML = ""
	document.getElementById("answerprompt").innerHTML = ""

start_timed_game = ->
	for j in [0...5]
		await show_instruction "trialinstruction_multi"
		for i in [0...100]
			document.getElementById("trialscore").innerHTML = ""
			document.getElementById("answerprompt").innerHTML = ""


			#await new Promise (a) -> setTimeout a, 300
			await pause_rendered 0.3
			await trial_n_and_n(
				Math.round(Math.random()*2) + 1,
				Math.round(Math.random()*2) + 1
				)
			await new Promise (a) -> setTimeout a, 1000
			#await pause_rendered 1.0
		
		document.getElementById("trialscore").innerHTML = ""
		document.getElementById("answerprompt").innerHTML = ""



logger = (msg) ->
	console.log msg

get_websocket_logger = (name) ->
	url = WS_LOG_URL + "?name=#{name}"
	socket = new WebSocket url
	await new Promise (accept, reject) ->
		socket.addEventListener "open", -> accept()
		socket.addEventListener "error", (event) -> reject(event)
	lgr = (msg) ->
		console.log msg
		socket.send JSON.stringify msg
	return lgr

get_logger = (name) ->
	url = POST_LOG_URL + "?name=#{name}"
	data = await (await fetch url).json()
	session_id = data.session_id
	url = POST_LOG_URL + "?session_id=#{session_id}"
	lgr = (msg) ->
		console.log msg
		fetch url,
			method: "POST"
			body: JSON.stringify msg

window.launch_game = ->
	name = document.getElementById("name").value
	try
		logger = await get_logger name
	catch error
		console.error "Starting logger failed", error
		alert "Failed to start logging. Retry."
		return
	document.getElementById("startscreen").remove()
	await document.body.requestFullscreen()

	url = (new URL window.location.href)
	# Wait a bit before starting
	#await pause_rendered 2
	switch url.searchParams.get("game")
		when "static_forced" then await start_static_game()
		when "corners" then await start_corner_game()
		when "timed" then await start_timed_game()
		else await start_game()
	
	await document.exitFullscreen()
	document.getElementById("endscore").innerHTML = Math.round(total_score)
	document.getElementById("endscreen").style["display"] = "flex"

</script>

</body>
</html>
