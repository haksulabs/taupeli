<html>
<head>
<style>
#startscreen {
	position: fixed;
	display: flex;
	align-items: center;
	justify-content: center;
	width: 100%;
	height: 100%;
	background-color: black;
	color: white;
	z-index: 10;
	font-size: x-large;
}

#endscreen {
	display: none;
	
	position: fixed;
	align-items: center;
	justify-content: center;
	width: 100%;
	height: 100%;
	background-color: black;
	color: white;
	z-index: 11;
	font-size: x-large;

}

#trialscore {
	position: absolute;
	display: block;
  	text-align: center;
	bottom: 53%;
	width: 100%;
	color: white;
	font-size: large;
	background-color: black;
}

#answerprompt {
	position: absolute;
	display: block;
  	text-align: center;
	bottom: 70%;
	width: 100%;
	color: white;
	font-size: xx-large;
	background-color: black;
	cursor: none;

}

#endscreen * {
	font-size: x-large;
}

#startscreen * {
	font-size: x-large;
}

body {
	margin: 0;
	background-color: black;
}

body > canvas {
	cursor: none;
}

.instruction {
	position: fixed;
	display: none;
	align-items: center;
	justify-content: center;
	width: 100%;
	height: 100%;
	background-color: black;
	color: white;
	z-index: 10;
	font-size: large;
	cursor: none;
}

.instruction > div {
	width: 50%;
	cursor: none;
}

</style>

</head>
<body>
<div style="position: absolute; font-size: large; color: white;">
	Score: <span id="score"></span>
	<br>Trial number: <span id="trial_n"</span>
</div>

<div id="trialscore">
</div>

<div id="answerprompt">
</div>

<div class="instruction" id="forcedinstruction">
<div>
<h1>TOPELI 2: Select the critical object</h1>
<p>Objects appear from left and right and are visible for a moment. Select with
arrow keys (&#8678; &#8680;) which one is first at the center.</p>
<p>Right answer gives 100 points, wrong answer -200 points.</p>
<p>Press any key to continue.</p>

<h1>TOPELI 2: Valitse kriittinen kohde</h1>
<p>Kohteet tulevat vasemmalta ja oikealta ja lähestyvät keskilinjaa. Ne ovat näkyvissä vain hetken. Valitse 
nuolinäppäimillä (&#8678; &#8680;) kumpi kohde saavuttaisi ruudun keskilinjan ensin.</p>
<p>Oikeasta vastauksesta 100 pistettä, Väärästä -200 pistettä.</p>
<p>Paina jotain näppäintä aloittaaksesi.</p>

</div>
</div>

<div class="instruction" id="forcedinstruction_practice">
<div>
<h1> TOPELI 2: Select the critical object, practice round </h1>
<p>Objects appear from left and right and are visible for a moment. Select with
arrow keys (&#8678; &#8680;) which one is first at the center.</p>
<p>Right answer gives 100 points, wrong answer -200 points.</p>
<p>Press any key to continue.</p>

<h1> TOPELI 2: Valitse kriittinen kohde,  harjoituskierros</h1>
<p>Kohteet tulevat vasemmalta ja oikealta ja lähestyvät keskilinjaa. Ne ovat näkyvissä vain hetken. Valitse 
nuolinäppäimillä (&#8678; &#8680;) kumpi kohde saavuttaisi ruudun keskilinjan ensin.</p>
<p>Oikeasta vastauksesta 100 pistettä, Väärästä -200 pistettä.</p>
<p>Paina jotain näppäintä aloittaaksesi.</p>

</div>
</div>



<div class="instruction" id="nonforcedinstruction">
<div>
<h1>TOPELI 3: Select the critical object or pass</h1>
<p>Objects appear from left and right and are visible for a moment. Select with
arrow keys (&#8678; &#8680;) which one is first at the center, or pass giving
and answer by pressing down  &#8681;.</p>
<p>Right answer gives 100 points, wrong answer -200 points and passing gives 0 points.</p>
<p>Press any key to continue.</p>

<h1>TOPELI 3: Valitse kriittinen kohde tai ohita</h1>
<p>Kohteet tulevat vasemmalta ja oikealta ja lähestyvät keskilinjaa. Ne ovat näkyvissä vain hetken. Valitse 
nuolinäppäimillä (&#8678; &#8680;) kumpi kohde saavuttaisi ruudun keskilinjan ensin, tai ohita 
painamalla alanuolta &#8681; .</p>
<p>Oikeasta vastauksesta 100 pistettä, väärästä -200 pistettä. Ohittamisesta 0 pistettä </p>
<p>Paina jotain näppäintä aloittaaksesi.</p>


</div>
</div>


<div class="instruction" id="nonforcedinstruction_practice">
<div>
<h1>TOPELI 3: Select the critical object or pass, practice rounds</h1>
<p>Objects appear from left and right and are visible for a moment. Select with
arrow keys (&#8678; &#8680;) which one is first at the center, or pass giving
and answer by pressing down  &#8681;.</p>
<p>Right answer gives 100 points, wrong answer -200 points and passing gives 0 points.</p>
<p>Press any key to continue.</p>

<h1>TOPELI 3: Valitse kriittinen kohde tai ohita, harjoituskierros</h1>
<p>Kohteet tulevat vasemmalta ja oikealta ja lähestyvät keskilinjaa. Ne ovat näkyvissä vain hetken. Valitse 
nuolinäppäimillä (&#8678; &#8680;) kumpi kohde saavuttaisi ruudun keskilinjan ensin, tai ohita 
painamalla alanuolta &#8681; .</p>
<p>Oikeasta vastauksesta 100 pistettä, väärästä -200 pistettä. Ohittamisesta 0 pistettä </p>
<p>Paina jotain näppäintä aloittaaksesi.</p>

</div>
</div>




<div class="instruction" id="trialinstruction">
<div>
<h1>TOPELI 1: Select the critical object</h1>
<p>Objects appear from left and right and approach the center. Select with
arrow keys (&#8678; &#8680;) which one is first at the center.</p>
<p>The faster you decide, the more points you get. Wrong answer gives double negative points.</p>
<p>Press any key to continue.</p>

<h1>TOPELI 1: Valitse kriittinen kohde </h1>
<p>Kohteet tulevat vasemmalta ja oikealta ja lähestyvät keskilinjaa. Valitse nuolinäppäimillä (&#8678; &#8680;) kumpi kohde saavuttaa keskilinjan ensin. </p>
<p>Nopeammasta vastauksesta saa enemmän pisteitä. Väärästä vastauksesta saa kaksinkertaisen määrän miinuspisteitä.</p>
<p>Paina jotain näppäintä aloittaaksesi.</p>

</div>
</div>


<div class="instruction" id="trialinstruction_practice">
<div>
<h1>TOPELI 1: Select the critical object, practice rounds</h1>
<p>Objects appear from left and right and approach the center. Select with
arrow keys (&#8678; &#8680;) which one is first at the center.</p>
<p>The faster you decide, the more points you get. Wrong answer gives double negative points.</p>
<p>Press any key to continue.</p>

<h1>TOPELI 1: Valitse kriittinen kohde, harjoituskierros </h1>
<p>Kohteet tulevat vasemmalta ja oikealta ja lähestyvät keskilinjaa. Valitse nuolinäppäimillä (&#8678; &#8680;) kumpi kohde saavuttaa keskilinjan ensin. </p>
<p>Nopeammasta vastauksesta saa enemmän pisteitä. Väärästä vastauksesta saa kaksinkertaisen määrän miinuspisteitä.</p>
<p>Paina jotain näppäintä aloittaaksesi.</p>



</div>
</div>


<div id="startscreen">
	<form onsubmit="launch_game(); return false;">
	<input type="text" id="name" placeholder="Session id or name" />
	<input type="submit" id="startbutton" value="Start"></button>
	</form>
</div>

<div id="endscreen">
	<div>
	<div>
		Done! Total score <span id="endscore"></span>.
	</div>
	<form>
		<input type="submit" value="Restart"></input>
	</form>
	</div>
</div>
<script type="text/javascript" src="coffeescript.js"></script>
<script type="text/javascript" src="three.js"></script>

<script type="text/coffeescript">

# TODO: dehardcode
LOG_URL = "wss://taupeli.duckdns.org/log/"

scene = new THREE.Scene()
camera = new THREE.OrthographicCamera -1, 1, -1, 1, 0.1, 1000
camera.position.z = 5

renderer = new THREE.WebGLRenderer antialias: true
document.body.appendChild renderer.domElement

render = ->
	el = document.body
	w = el.clientWidth
	h = el.clientHeight
	renderer.setSize w, h
	h = h/w
	w = 1
	camera.left = -w
	camera.right = w
	camera.bottom = -h
	camera.top = h
	camera.updateProjectionMatrix() # May be expensive
	renderer.render scene, camera

new_object = ->
	geometry = new THREE.SphereGeometry(0.01, 32, 16)
	material = new THREE.MeshBasicMaterial color: 0xffffff
	object = new THREE.Mesh geometry, material
	scene.add object
	return object

prev_time = undefined
events_seen = []
document.body.addEventListener("keydown", (ev) -> events_seen.push(ev))
document.body.addEventListener("touchstart", (ev) -> events_seen.push(ev))
next_frame = -> new Promise (resolve, reject) ->
	requestAnimationFrame (time) ->
		prev_time = time
		events = [events_seen...]
		events_seen = []
		resolve([time/1000, events])

pause_rendered = (seconds) ->
	while true
		[time, events] = await next_frame()
		render()
		if not t0?
			t0 = time
		if time - t0 > seconds
			return

reset_events = ->
	events_seen = []

line = new THREE.Line(
	new THREE.BufferGeometry().setFromPoints([
		new THREE.Vector3(0, 1, 0),
		new THREE.Vector3(0, -1, 0)
		])
	)
scene.add line

left = new_object()
right = new_object()

left.position.x = -100
right.position.x = 100

total_score = 0
n_trials = 0
update_score = (score) ->
	total_score += score*100
	n_trials += 1
	document.getElementById("score").innerHTML = Math.round(total_score)

display_trial_score = (score) -> 
	document.getElementById("trialscore").innerHTML = Math.round(score*100)

get_speeds = ->
	left_speed = (Math.random()*0.15 + 0.5)
	right_speed = -(Math.random()*0.15 + 0.5)
	[left_speed, right_speed]

trial = ->
	trialtype = 'base'
	left.position.x = -1
	right.position.x = 1
	
	left.material.color.setHex 0xffffff
	right.material.color.setHex 0xffffff

	[left_speed, right_speed] = get_speeds()

	left_ttc = Math.abs 1/left_speed
	right_ttc = Math.abs 1/right_speed
	
	ttc_diff = right_ttc - left_ttc
	###	
	ttc_diff = Math.random() - 0.5
	right_delay = ttc_diff + left_ttc - right_ttc
	
	if right_delay > 0 
		right.position.x += (right_delay * -right_speed)
		right_ttc = Math.abs right.position.x / right_speed
	else
		left.position.x += right_delay * left_speed
		left_ttc = Math.abs left.position.x / left_speed
	###
	
	min_ttc = Math.min left_ttc, right_ttc

	side_selected = 0
	score = undefined

	t = undefined
	t0 = undefined

	trialinfo =
		type: trialtype
		v0: left_speed
		v1: right_speed
		x0: left.position.x
		x1: right.position.x
		ttcdiff: ttc_diff
		minttc: min_ttc
	


	trialdone = 0
	
	reset_events()
	while true
		[time, events] = await next_frame()
		if not t?
			t = time
			t0 = time
		dt = time - t
		t = time
		for event in events
			# Don't accept keypress unless both objects are visible
			#if Math.abs(right.position.x) > 1 or Math.abs(left.position.x) > 1
			#	break
			if score?
				break
			if event.key == "ArrowLeft" or event.touches?[0].clientX < event.target.clientWidth/2
				side_selected = -1
				left.material.color.setHex 0xff00ff
			else if event.key == "ArrowRight" or event.touches?[0].clientX > event.target.clientWidth/2
				side_selected = 1
				right.material.color.setHex 0xff00ff
			else 
				break
			score = (min_ttc - (t - t0))/min_ttc
			if side_selected == Math.sign(ttc_diff)
				score *= -2
				trialinfo.correct = 0
			else if side_selected == -Math.sign(ttc_diff)
				trialinfo.correct = 1
			trialinfo.reply_ttc_time = min_ttc - (t-t0)
			trialinfo.reply_time = (t-t0)

			update_score(score)
			trialinfo.score = score
			trialinfo.n_trials = n_trials

		left.position.x += left_speed * dt
		right.position.x += right_speed * dt
		
		if left.position.x > 0
			left.position.x = 0
			trialdone = 1
		if right.position.x < 0
			right.position.x = 0
			trialdone = 1
			
		if trialdone
			if not score?
				score = 0
				update_score(score)
				trialinfo.score = score
				trialinfo.n_trials = n_trials
			display_trial_score(score)
			logger(trialinfo)
			return
		
	
		render()


trial_flash_forced = ->
	trialtype = 'flash_forced'
	answertime = 0
	left.position.x = -1
	right.position.x = 1
	
	left.material.color.setHex 0xffffff
	right.material.color.setHex 0xffffff

	[left_speed, right_speed] = get_speeds()
	
	left_ttc = Math.abs 1/left_speed
	right_ttc = Math.abs 1/right_speed
	
	ttc_diff = right_ttc - left_ttc
	###	
	ttc_diff = Math.random() - 0.5
	right_delay = ttc_diff + left_ttc - right_ttc
	
	if right_delay > 0 
		right.position.x += (right_delay * -right_speed)
		right_ttc = Math.abs right.position.x / right_speed
	else
		left.position.x += right_delay * left_speed
		left_ttc = Math.abs left.position.x / left_speed
	###
	
	min_ttc = Math.min left_ttc, right_ttc
	disappearlocation = Math.random()*0.5 + 0.4

	side_selected = 0
	score = undefined

	t = undefined
	t0 = undefined

	trialinfo =
		type: trialtype
		v0: left_speed
		v1: right_speed
		x0: left.position.x
		x1: right.position.x
		ttcdiff: ttc_diff
		minttc: min_ttc
		disappear: disappearlocation

	


	trialdone = 0
	
	reset_events()
	while true
		[time, events] = await next_frame()
		if not t?
			t = time
			t0 = time
		dt = time - t
		t = time
		for event in events
			# Don't accept keypress unless both objects are visible
			#if Math.abs(right.position.x) > 1 or Math.abs(left.position.x) > 1
			if not answertime
				break
			if score?
				break
			if event.key == "ArrowLeft" or event.touches?[0].clientX < event.target.clientWidth/2
				side_selected = -1
				left.material.color.setHex 0xff00ff
				trialdone = 1
			else if event.key == "ArrowRight" or event.touches?[0].clientX > event.target.clientWidth/2
				side_selected = 1
				right.material.color.setHex 0xff00ff
				trialdone = 1
			else
				break
			#score = (min_ttc - (t - t0))/min_ttc
			score = 1
			if side_selected == Math.sign(ttc_diff)
				score *= -2
				trialinfo.correct = 0
			else if side_selected == -Math.sign(ttc_diff)
				trialinfo.correct = 1
			trialinfo.reply_ttc_time = min_ttc - (t-t0)
			trialinfo.reply_time = (t-t0)

			update_score(score)
			trialinfo.score = score
			trialinfo.n_trials = n_trials

		
		if left.position.x > 0-disappearlocation || right.position.x < 0+disappearlocation 
			left.position.x = -100
			right.position.x = 100
			left_speed = 0
			right_speed = 0
			answertime = 1
			document.getElementById("answerprompt").innerHTML = 'which one first at the center <br>  &#8678; press an arrow key &#8680; '
			
		else
			left.position.x += left_speed * dt
			right.position.x += right_speed * dt
		


		if left.position.x > 0
			left.position.x = 0
			trialdone = 1
		if right.position.x < 0
			right.position.x = 0
			trialdone = 1
			
		if trialdone
			if not score?
				score = 0
				update_score(score)
				trialinfo.score = score
				trialinfo.n_trials = n_trials
			display_trial_score(score)
			logger(trialinfo)
			return
		
	
		render()



trial_flash_nonforced = ->
	trialtype = 'flash_nonforced'
	answertime = 0
	left.position.x = -1
	right.position.x = 1
	
	left.material.color.setHex 0xffffff
	right.material.color.setHex 0xffffff


	[left_speed, right_speed] = get_speeds()
	
	left_ttc = Math.abs 1/left_speed
	right_ttc = Math.abs 1/right_speed
	
	ttc_diff = right_ttc - left_ttc
	###	
	ttc_diff = Math.random() - 0.5
	right_delay = ttc_diff + left_ttc - right_ttc
	
	if right_delay > 0 
		right.position.x += (right_delay * -right_speed)
		right_ttc = Math.abs right.position.x / right_speed
	else
		left.position.x += right_delay * left_speed
		left_ttc = Math.abs left.position.x / left_speed
	###
	
	min_ttc = Math.min left_ttc, right_ttc
	disappearlocation = Math.random()*0.5 + 0.4

	side_selected = 0
	score = undefined

	t = undefined
	t0 = undefined

	trialinfo =
		type: trialtype
		v0: left_speed
		v1: right_speed
		x0: left.position.x
		x1: right.position.x
		ttcdiff: ttc_diff
		minttc: min_ttc
		disappear: disappearlocation

	


	trialdone = 0
	
	reset_events()
	while true
		[time, events] = await next_frame()
		if not t?
			t = time
			t0 = time
		dt = time - t
		t = time
		for event in events
			# Don't accept keypress unless both objects are visible
			#if Math.abs(right.position.x) > 1 or Math.abs(left.position.x) > 1
			if not answertime
				break
			if score?
				break
			if event.key == "ArrowLeft" or event.touches?[0].clientX < event.target.clientWidth/2
				side_selected = -1
				left.material.color.setHex 0xff00ff
				trialdone = 1
			else if event.key == "ArrowRight" or event.touches?[0].clientX > event.target.clientWidth/2
				side_selected = 1
				right.material.color.setHex 0xff00ff
				trialdone = 1
			else if event.key == "ArrowDown" 
				side_selected = 0
				right.material.color.setHex 0xff00ff
				trialdone = 1
				trialinfo.correct = 2
				score = 0
			else
				break
			#score = (min_ttc - (t - t0))/min_ttc
		
			if side_selected == Math.sign(ttc_diff)
				score = -2
				trialinfo.correct = 0
			else if side_selected == -Math.sign(ttc_diff)
				trialinfo.correct = 1
				score = 1
			trialinfo.reply_ttc_time = min_ttc - (t-t0)
			trialinfo.reply_time = (t-t0)

			update_score(score)
			trialinfo.score = score
			trialinfo.n_trials = n_trials

		
		if left.position.x > 0-disappearlocation || right.position.x < 0+disappearlocation 
			left.position.x = -100
			right.position.x = 100
			left_speed = 0
			right_speed = 0
			answertime = 1
			document.getElementById("answerprompt").innerHTML = 'which one first at the center <br>  &#8678; press arrow key &#8680; <br> or &#8681; to pass '
		else
			left.position.x += left_speed * dt
			right.position.x += right_speed * dt
		


		if left.position.x > 0
			left.position.x = 0
			trialdone = 1
		if right.position.x < 0
			right.position.x = 0
			trialdone = 1
			
		if trialdone
			if not score?
				score = 0
				update_score(score)
				trialinfo.score = score
				trialinfo.n_trials = n_trials
			display_trial_score(score)
			logger(trialinfo)
			return
		
	
		render()


show_instruction = (id) ->
	el = document.getElementById id
	el.style.display = "flex"
	new Promise (accept) ->
		do_accept = ->
			el.style.display = "none"
			accept()
		document.body.addEventListener "keyup", do_accept
		el.addEventListener "click", do_accept

start_game = ->
	max_blocks = 1
	max_trials = 25
	
	for b in [0...max_blocks]
		await show_instruction "trialinstruction_practice"
		for i in [0...max_trials]
			document.getElementById("trial_n").innerHTML = "#{i+1} / #{max_trials}"
			document.getElementById("trialscore").innerHTML = ""
			document.getElementById("answerprompt").innerHTML = ""
			await trial()
			#await trial_flash_forced()
			#await trial_flash_nonforced()
			await new Promise (a) -> setTimeout a, 1000
		document.getElementById("trial_n").innerHTML = ""
		document.getElementById("trialscore").innerHTML = ""
		document.getElementById("answerprompt").innerHTML = ""
	
		await show_instruction "forcedinstruction_practice"
		for i in [0...max_trials]
			document.getElementById("trial_n").innerHTML = "#{i+1} / #{max_trials}"
			document.getElementById("trialscore").innerHTML = ""
			document.getElementById("answerprompt").innerHTML = ""
			#await trial()
			await trial_flash_forced()
			#await trial_flash_nonforced()
			await new Promise (a) -> setTimeout a, 1000
		document.getElementById("trial_n").innerHTML = ""
		document.getElementById("trialscore").innerHTML = ""
		document.getElementById("answerprompt").innerHTML = ""
		
		await show_instruction "nonforcedinstruction_practice"
		for i in [0...max_trials]
			document.getElementById("trial_n").innerHTML = "#{i+1} / #{max_trials}"
			document.getElementById("trialscore").innerHTML = ""
			document.getElementById("answerprompt").innerHTML = ""
			#await trial()
			#await trial_flash_forced()
			await trial_flash_nonforced()
			await new Promise (a) -> setTimeout a, 1000
		document.getElementById("trial_n").innerHTML = ""
		document.getElementById("trialscore").innerHTML = ""
		document.getElementById("answerprompt").innerHTML = ""



	total_score = 0
		
	max_blocks = 3
	max_trials = 75
	
	for b in [0...max_blocks]

		await show_instruction "trialinstruction"
		for i in [0...max_trials]
			document.getElementById("trial_n").innerHTML = "#{i+1} / #{max_trials}"
			document.getElementById("trialscore").innerHTML = ""
			document.getElementById("answerprompt").innerHTML = ""
			await trial()
			#await trial_flash_forced()
			#await trial_flash_nonforced()
			await new Promise (a) -> setTimeout a, 1000
		document.getElementById("trial_n").innerHTML = ""
		document.getElementById("trialscore").innerHTML = ""
		document.getElementById("answerprompt").innerHTML = ""
	
		await show_instruction "forcedinstruction"
		for i in [0...max_trials]
			document.getElementById("trial_n").innerHTML = "#{i+1} / #{max_trials}"
			document.getElementById("trialscore").innerHTML = ""
			document.getElementById("answerprompt").innerHTML = ""
			#await trial()
			await trial_flash_forced()
			#await trial_flash_nonforced()
			await new Promise (a) -> setTimeout a, 1000
		document.getElementById("trial_n").innerHTML = ""
		document.getElementById("trialscore").innerHTML = ""
		document.getElementById("answerprompt").innerHTML = ""
		
		await show_instruction "nonforcedinstruction"
		for i in [0...max_trials]
			document.getElementById("trial_n").innerHTML = "#{i+1} / #{max_trials}"
			document.getElementById("trialscore").innerHTML = ""
			document.getElementById("answerprompt").innerHTML = ""
			#await trial()
			#await trial_flash_forced()
			await trial_flash_nonforced()
			await new Promise (a) -> setTimeout a, 1000
		document.getElementById("trial_n").innerHTML = ""
		document.getElementById("trialscore").innerHTML = ""
		document.getElementById("answerprompt").innerHTML = ""

		

logger = (msg) ->
	console.log msg

get_logger = (name) ->
	url = LOG_URL + "?name=#{name}"
	socket = new WebSocket url
	await new Promise (accept, reject) ->
		socket.addEventListener "open", -> accept()
		socket.addEventListener "error", (event) -> reject(event)
	lgr = (msg) ->
		console.log msg
		socket.send JSON.stringify msg
	return lgr

window.launch_game = ->
	name = document.getElementById("name").value
	try
		logger = await get_logger name
	catch error
		console.error "Starting logger failed", error
		alert "Failed to start logging. Retry."
		return
	document.getElementById("startscreen").remove()
	await document.body.requestFullscreen()
	
	# Wait a bit before starting
	#await pause_rendered 2
	await start_game()
	await document.exitFullscreen()
	document.getElementById("endscore").innerHTML = Math.round(total_score)
	document.getElementById("endscreen").style["display"] = "flex"
</script>

</body>
</html>
