#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Aug  4 14:13:20 2022

@author: t
"""

import pandas as pd
import numpy as np 
import scipy.stats as stats
from sklearn.preprocessing import StandardScaler

from preprocess_taupelidata import corners_preprocess
scaler = StandardScaler()



def accuracy(df):
    
    # takes dataframe of trials (generated by taupelidata_to_dataframe.py)
    # calculates basic accuracy
    
    names = df.name.unique()
    types = 'trial_corners_forced'
    typ=types
    df_correct = pd.DataFrame()
    acc = len(df[df.correct==1]) / len(df[((df['correct']==1) | (df['correct']==0))])
    d = {'name': 'total', 'type': typ, 'condition':'all', 'accuracy': acc }
    df_d = pd.DataFrame([d])
    df_correct = pd.concat([df_correct,df_d],ignore_index=True)
    #df_correct = df_correct.append(d,ignore_index=True)
    
    # separate conditions
    #conditions = df.condition.unique()
    #conditions.sort()
    conditions = [12,34,23,41,24,13]
    for con in conditions: 
        acc = len( df[(df.correct == 1) & (df.condition==con)] ) / \
            len(df[  ((df.correct == 1) | (df['correct'] == 0)) & (df.condition==con)    ])
            
        d = {'name': 'total', 'type': typ, 'condition': con, 'accuracy': acc }
        #df_correct = df_correct.append(d, ignore_index=True)
        df_d = pd.DataFrame([d])
        df_correct = pd.concat([df_correct,df_d],ignore_index=True)

    
    for name in names:
        kh_df = df[(df['name'] == name) & (df['type'] == typ)]
        acc = len(kh_df[kh_df.correct == 1]) / \
            len(kh_df[((kh_df['correct'] == 1) | (kh_df['correct'] == 0))])
        d = {'name': name, 'type': typ, 'condition':'all', 'accuracy': acc}
        df_d = pd.DataFrame([d])
        df_correct = pd.concat([df_correct,df_d],ignore_index=True)
        #df_correct = df_correct.append(d, ignore_index=True)



# condition per kh

    for con in conditions: 
     

        for name in names:
            kh_df = df[(df['name'] == name) & (df['type'] == typ)]
            acc = len( kh_df[(kh_df.correct == 1) & (kh_df.condition==con)] ) / \
                len(kh_df[  ((kh_df.correct == 1) | (kh_df['correct'] == 0)) & (kh_df.condition==con)    ])
    

            d = {'name': name, 'type': typ, 'condition': con, 'accuracy': acc }
            df_d = pd.DataFrame([d])
            df_correct = pd.concat([df_correct,df_d],ignore_index=True)
            



    return df_correct
    

df = pd.read_csv('taupelidata_corners_pilotit.csv')
orig_df = corners_preprocess(df)
df = orig_df



# df = pd.read_csv('taupelidata_corners_pilotit.csv')

# df['abs_ttcdiff'] = np.abs(df.ttcdiff)
# df['abs_ttcdiff_norm'] = scaler.fit_transform(df[['abs_ttcdiff']])

# df['minttc_norm'] = scaler.fit_transform(df[['minttc']])

# df['abs_v0'] = np.abs(df.v0)
# df['abs_v1'] = np.abs(df.v1)
# df['max_v'] = df[['abs_v0','abs_v1']].max(axis=1)
# df['min_v'] = df[['abs_v0','abs_v1']].min(axis=1)
# df['delta_v'] = df.max_v-df.min_v
# df['delta_v_norm'] = scaler.fit_transform(df[['delta_v']])

# df['min_v_norm'] = scaler.fit_transform(df[['min_v']])
# df['max_v_norm'] = scaler.fit_transform(df[['max_v']])


# df['x0_end'] = np.sign(df.x0) * (np.abs(df.x0) - df.v0*0.5)
# df['x1_end'] = np.sign(df.x1) * (np.abs(df.x1) - df.v1*0.5)

# df['y0_end'] = np.sign(df.y0) * (np.abs(df.y0) - df.v0*0.5)
# df['y1_end'] = np.sign(df.y1) * (np.abs(df.y1) - df.v1*0.5)

# df['xseparation'] = np.abs(df.x1_end - df.x0_end)
# df['yseparation'] = np.abs(df.y1_end - df.y0_end)
# df['xseparation_norm'] = scaler.fit_transform(df[['xseparation']])
# df['yseparation_norm'] = scaler.fit_transform(df[['yseparation']])

# df['tot_separation'] = np.sqrt(df['xseparation']**2 + df['yseparation']**2)
# df['tot_separation_norm'] = scaler.fit_transform(df[['tot_separation']])

# df['xenddif'] = np.abs(np.abs(df.x1_end) - np.abs(df.x0_end))
# df['yenddif'] = np.abs(np.abs(df.y1_end) - np.abs(df.y0_end))

# df['xenddif_norm'] = scaler.fit_transform(df[['xenddif']])
# df['yenddif_norm'] = scaler.fit_transform(df[['yenddif']])

# df['totdif'] = np.sqrt(df['xenddif']**2 + df['yenddif']**2)
# df['totdif_norm'] = scaler.fit_transform(df[['totdif']])

# df['stagger'] = df['startpos'].isin([15,51])
# df['stagger'] = df['stagger'].astype(int)
# orig_df = df.copy()
# df['x0_end'] = np.sign(df.x0) * (np.abs(df.x0) - df.v0*0.5)
# df['x1_end'] = np.sign(df.x1) * (np.abs(df.x1) - df.v1*0.5)
# df['x0_kauempana'] = np.sign((np.abs(df['x0_end']) - np.abs(df['x1_end'])))                             
# df['overtake_oclusion'] = (df['x0_kauempana'] == np.sign(df['ttcdiff']))
# df['overtake_oclusion'] = df['overtake_oclusion'].astype(int)


df_orig = df.copy()
df_orig = df_orig[df_orig['n_trials']>20]

df_acc_all = accuracy(df_orig)
df_acc_all.to_csv('accuracy_all.csv', index=False)


# filter trials with particular startposition differences
df_same = df_orig[(np.abs(df_orig.x0)-np.abs(df_orig.x1) == 0)]
df_differ = df_orig[ df['stag1'] ==1]

#df_differ = df_orig[(np.abs(df_orig.x0)-np.abs(df_orig.x1) != 0)]

df_overtake = df_differ[df_differ['overtake_oclusion']==1]
df_notovertake = df_differ[df_differ['overtake_oclusion']==0]

df_acc_same = accuracy(df_same)
df_acc_differ = accuracy(df_differ)

df_acc_same.to_csv('accuracy_same.csv', index=False)
df_acc_differ.to_csv('accuracy_differ.csv', index=False)

df_acc_overtake = accuracy(df_overtake)
df_acc_notovertake = accuracy(df_notovertake)

df_acc_all['startpos same'] = df_acc_same['accuracy']
df_acc_all['startpos differ'] = df_acc_differ['accuracy']



#df_acc_all contains all results, use this to calculate further

# calculate standard deviations etc

df_acc_std = pd.DataFrame()

conditions = df_acc_all.condition.unique()
for con in conditions:
    df_acc_con = df_acc_all[(df_acc_all.condition==con) & (df_acc_all.name!='total')]
    
    
    std_all = df_acc_con['accuracy'].std()
    std_same = df_acc_con['startpos same'].std()
    std_differ = df_acc_con['startpos differ'].std()
    
    # paired ttest
    stats.ttest_rel(df_acc_con['startpos same'], df_acc_con['startpos differ'])
    res = stats.ttest_rel(df_acc_con['startpos same'], df_acc_con['startpos differ'])
    
    d = {'condition':con, 'std_all':std_all, 'std_startpos_same':std_same, 'std_startpos_differ':std_differ,'ttest_p': res.pvalue}
    df_d = pd.DataFrame([d])
    df_acc_std = pd.concat([df_acc_std,df_d],ignore_index=True)
    #df_acc_std = df_acc_std.append(d,ignore_index=True)




# # startposition difference

# df_same = df[(np.abs(df.x0)-np.abs(df.x1) == 0)]
# df_differ = df[(np.abs(df.x0)-np.abs(df.x1) != 0)]


# df = df_same
# acc = len(df[df.correct==1]) / len(df[((df['correct']==1) | (df['correct']==0))])
# d = {'name': 'total', 'type': typ, 'accuracy': acc,'starpos':'same' }
# df_correct = df_correct.append(d,ignore_index=True)

# df = df_differ
# acc = len(df[df.correct==1]) / len(df[((df['correct']==1) | (df['correct']==0))])
# d = {'name': 'total', 'type': typ, 'accuracy': acc,'starpos':'differ' }
# df_correct = df_correct.append(d,ignore_index=True)

# # startposition difference per kh 

# df = df_same
# names = df.name.unique()
# types = 'trial_corners_forced'
# typ=types
# df_correct = pd.DataFrame()
# df = df[df['type']==types]

# acc = len(df[df.correct==1]) / len(df[((df['correct']==1) | (df['correct']==0))])
# d = {'name': 'total', 'type': typ, 'accuracy': acc }
# df_correct = df_correct.append(d,ignore_index=True)

# for name in names:
#     kh_df = df[(df['name'] == name) & (df['type'] == typ)]
#     acc = len(kh_df[kh_df.correct == 1]) / \
#         len(kh_df[((kh_df['correct'] == 1) | (kh_df['correct'] == 0))])
#     d = {'name': name, 'type': typ, 'accuracy': acc}
#     df_correct = df_correct.append(d, ignore_index=True)
       
# print(df_correct)

# # separate conditions with same/differ startpos

# conditions = df.condition.unique()
# conditions.sort()

# for con in conditions: 
#     acc = len( df[(df.correct == 1) & (df.condition==con)] ) / \
#         len(df[  ((df.correct == 1) | (df['correct'] == 0)) & (df.condition==con)    ])
        
#     d = {'name': 'total', 'type': typ, 'accuracy': acc, 'condition': con}
#     df_correct = df_correct.append(d, ignore_index=True)
# df_correct_same = df_correct




# # startposition difference per kh 

# df = df_differ
# names = df.name.unique()
# types = 'trial_corners_forced'
# typ=types
# df_correct = pd.DataFrame()
# df = df[df['type']==types]

# acc = len(df[df.correct==1]) / len(df[((df['correct']==1) | (df['correct']==0))])
# d = {'name': 'total', 'type': typ, 'accuracy': acc }
# df_correct = df_correct.append(d,ignore_index=True)

# for name in names:
#     kh_df = df[(df['name'] == name) & (df['type'] == typ)]
#     acc = len(kh_df[kh_df.correct == 1]) / \
#         len(kh_df[((kh_df['correct'] == 1) | (kh_df['correct'] == 0))])
#     d = {'name': name, 'type': typ, 'accuracy': acc}
#     df_correct = df_correct.append(d, ignore_index=True)
       
# print(df_correct)

# # separate conditions with same/differ startpos

# conditions = df.condition.unique()
# conditions.sort()

# for con in conditions: 
#     acc = len( df[(df.correct == 1) & (df.condition==con)] ) / \
#         len(df[  ((df.correct == 1) | (df['correct'] == 0)) & (df.condition==con)    ])
        
#     d = {'name': 'total', 'type': typ, 'accuracy': acc, 'condition': con}
#     df_correct = df_correct.append(d, ignore_index=True)
# df_correct_differ = df_correct


